# 宏编程
写在最前:
之前几乎没有遇到过需要使用宏编程的场景，在 rust 中第一次遇到，认为可以作一个深入一点的了解。

## 回顾之前 C 语言里面用到的宏
C语言中，宏(macro)作为一种预处理指令，用于定义代码中的符号常量或简短的代码片段替换。宏可以用来简化代码，提高代码可读性以及实现一些编程技巧。
#### 1. 无参数宏，定义常量
```c
#define PI 3.14159
```
#### 2. 带参数的宏，用于定义类似函数的功能
使用带有参数的宏需要注意副作用，例如
```c
#define SQUARE(x) ((x) * (x))
int a = 5,b;
b = SQUARE(a++);
```
> 一个比较明显的副作用的例子:
C 语言里面宏是简单的文本替换，当在代码中使用
```c
SQUARE(a++); 
// 预处理器将上述展开为:
((a++) * (a++))
```
导致副作用。宏参数 `x` 以表达式 `a++` 传递的，在这个展开过程中，`a++` 被计算了两次。意味着
1. `a++` 在第一次计算时将 `a` 的值 5 用于计算，并且增加 `a` 的值
2. `a` 在第二次 `a++` 计算时，值已经变为 6, 再次增加后变为 7
`a` 在一个表达式中被修改了两次，这些修改之间没有顺序点来定义执行次序。可能出现 (5 * 6) 等未定义行为的结果。多次求值引发副作用。

宏可以模拟函数的行为，但不是真正的函数。宏在编译前由预处理器处理，内联函数在编译阶段处理。宏缺乏类型检查等优点，很多情况下使用内联函数更加安全灵活。

## 下面关于宏编程的信息来源: rust 语言圣经
https://course.rs/advance/macro.html

# Macro 宏编程
在编程世界中谈“宏”色变。上面对于C语言中宏的使用相对危险，对于古老的语言 Lisp 来说，宏就是一个非常强大的帮手。

在 Rust 中宏到底是好是坏呢？

之前已经多次使用过宏，例如最简单的例子: println!("hello,world")
这里的 println! 就是一个最常用的宏，可以看到它和函数的最大区别是: 它在调用时多了一个 !, 除此之外还有 vec!, assert_eq!, 宏在 Rust 中无处不在。

println! 后面跟着的是 (), vec! 后面跟着的是 [], 宏的参数可以使用 ()、[] 以及 {}:
```rust
fn main(){
    println!("aaaa");
    println!["aaaa"];
    println!{"aaaa"};
}
```
跑了一下，发现编译确实能通过。

在 Rust 中宏分为两大类: 声明式宏(declarative macro) macro_rules! 
和三种过程宏(procedural macros):
- #[derive], 派生宏，可以为目标结构体或枚举派生指定的代码，例如 Debug 特征
- 类属性宏(Attribute-like macro), 用于为目标添加自定义的属性
- 类函数宏(Function-like macro), 看上去像函数调用

## 宏和函数的区别

## 元编程
宏是通过一种代码来生成另一种代码。
derive 属性，就会自动为结构体派生出相应特征所需的代码，例如 #[derive(Debug)], 还有熟悉的 println! 和 vec!, 所有这些宏都会展开成相应的代码，且很可能是长得多的代码。

### 可变参数
rust 的函数签名是固定的: 定义了两个参数，就必须传入两个参数。
宏可以拥有可变数量的参数，例如可以调用一个参数的 println!("hello"), 也可以调用两个参数的 println!("hello {}", name)。

### 宏展开
宏会被展开成其它代码，展开过程发生在编译器对代码进行解释之前。宏可以为指定的类型实现某个特征: 先将宏展开成实现特征的代码后，再被编译。

函数直到运行时才能被调用，而特征需要在编译器被实现。

### 宏的缺点
宏是基于代码再展开成代码，实现相比函数来说会更加复杂，宏的语法更为复杂，导致定义宏的代码相当地难读，难以理解和维护。

## 声明式宏 macro_rules!
在 Rust 中使用最广的就是声明式宏，它们也有一些其它的称呼，例如示例宏(macros by example), macro_rules! 
声明式宏允许我们写出类似 match 的代码。match 表达式是一个控制结构，其接收一个表达式，然后将表达式的结果与多个模式进行匹配，一旦匹配了某个模式，则该模式相关联的代码将被执行:
```rust
match target {
    模式1 => 表达式1,
    模式2 => {
        语句1;
        语句2;
        表达式2
    },
    _ => 表达式3
}
```
宏也是将一个值跟对应的模式进行匹配，且该模式会与特定的代码相关联。但是与 match 不同的是，宏里的值是一段 Rust 源代码(字面量)，模式用于跟这段源代码的结构相比较，一旦匹配，传入宏的那段源代码将被模式关联的代码所替换，最终实现宏展开。值得注意的是，所有的这些都是在编译期发生，并没有运行期的性能损耗。

### 简化版的 vec!
在动态数组 Vector 章节中，我们学习了使用 vec! 来便捷的初始化一个动态数组:
```rust
let v: Vec<u32> = vec![1, 2, 3];
```
最重要的是，通过 vec! 创建的动态数组支持任何元素类型，也并没有限制数组的长度，如果使用函数，我们是无法做到这一点的。

好在我们有 macro_rules!, 看看该如何使用它来实现 vec!, 以下是一个简化实现:
```rust
#[macro_export]
macro_rules! vec {
    (  $( $x: expr),*) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    }
}
```

> 关于上面程序的解释
```rust
#[macro_export]
// 属性用于声明接下来的宏可以在包外部被使用。公开了宏供其他依赖包或者库使用
macro_rules! vec{
    /*
    ($( $x: expr  ), *)
    宏的模式匹配部分,
    1.  $(...), * 这个模式匹配一组用逗号分隔的表达式
    2. $x: expr  表示一个 rust 表达式
    3. $($x: expr), * 表示匹配零个或多个用逗号分隔的 rust 表达式
    */
    ( $($x: expr ), *) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
        /*
        执行代码块的部分: 其中利用 $()* 表示这个代码块内部的内容会为每一个 $x 替换一次。
        temp_vec.push($x) 会为宏调用时提供的每一个表达式 $x 调用一次，向 temp_vec 中添加元素
        */
    };
}
```
